import jsPDF from "jspdf";

const MARGIN = 20;
const PAGE_W = 210; // A4 width in mm
const CONTENT_W = PAGE_W - MARGIN * 2;
const LINE_H = 6;
const FONT_SIZE = 11;
const TITLE_SIZE = 14;
const SMALL_SIZE = 9;

function addHeader(doc: jsPDF, title: string): number {
  let y = MARGIN;
  doc.setFontSize(TITLE_SIZE);
  doc.setFont("helvetica", "bold");
  doc.text(title, MARGIN, y);
  y += LINE_H + 2;

  doc.setFontSize(SMALL_SIZE);
  doc.setFont("helvetica", "normal");
  doc.setTextColor(120);
  doc.text(`StatMate — ${new Date().toLocaleDateString()}`, MARGIN, y);
  doc.setTextColor(0);
  y += LINE_H + 4;

  doc.setDrawColor(0);
  doc.setLineWidth(0.5);
  doc.line(MARGIN, y, PAGE_W - MARGIN, y);
  y += 6;

  return y;
}

function addSection(doc: jsPDF, y: number, label: string, value: string): number {
  if (y > 270) { doc.addPage(); y = MARGIN; }
  doc.setFontSize(FONT_SIZE);
  doc.setFont("helvetica", "bold");
  doc.text(label, MARGIN, y);
  doc.setFont("helvetica", "normal");
  const lines = doc.splitTextToSize(value, CONTENT_W);
  doc.text(lines, MARGIN, y + LINE_H);
  return y + LINE_H + lines.length * LINE_H + 2;
}

function addTable(doc: jsPDF, y: number, headers: string[], rows: string[][]): number {
  if (y > 250) { doc.addPage(); y = MARGIN; }
  const colW = CONTENT_W / headers.length;

  // Header
  doc.setFillColor(245, 245, 245);
  doc.rect(MARGIN, y - 4, CONTENT_W, LINE_H + 2, "F");
  doc.setFontSize(SMALL_SIZE);
  doc.setFont("helvetica", "bold");
  headers.forEach((h, i) => {
    doc.text(h, MARGIN + i * colW + 2, y);
  });
  y += LINE_H + 1;

  // Rows
  doc.setFont("helvetica", "normal");
  for (const row of rows) {
    if (y > 275) { doc.addPage(); y = MARGIN; }
    row.forEach((cell, i) => {
      doc.text(cell, MARGIN + i * colW + 2, y);
    });
    y += LINE_H;
  }
  y += 4;
  return y;
}

function addApa(doc: jsPDF, y: number, apa: string): number {
  if (y > 260) { doc.addPage(); y = MARGIN; }
  doc.setDrawColor(59, 130, 246);
  doc.setLineWidth(0.3);
  doc.line(MARGIN, y, PAGE_W - MARGIN, y);
  y += 4;

  doc.setFontSize(SMALL_SIZE);
  doc.setFont("helvetica", "bolditalic");
  doc.text("APA Result:", MARGIN, y);
  y += LINE_H;

  doc.setFont("helvetica", "italic");
  const lines = doc.splitTextToSize(apa, CONTENT_W);
  doc.text(lines, MARGIN, y);
  y += lines.length * LINE_H + 4;
  return y;
}

function addFooter(doc: jsPDF) {
  const pages = doc.getNumberOfPages();
  for (let i = 1; i <= pages; i++) {
    doc.setPage(i);
    doc.setFontSize(8);
    doc.setFont("helvetica", "normal");
    doc.setTextColor(150);
    doc.text("Generated by StatMate (statmate.org)", MARGIN, 290);
    doc.text(`Page ${i}/${pages}`, PAGE_W - MARGIN - 15, 290);
    doc.setTextColor(0);
  }
}

function toBlob(doc: jsPDF): Blob {
  return doc.output("blob");
}

// --- T-Test PDF ---
export function exportTTestPdf(data: {
  type: string; t: number; df: number; pValue: number; cohensD: number;
  ci95: [number, number]; meanDiff: number;
  group1Stats: { mean: number; sd: number; n: number };
  group2Stats: { mean: number; sd: number; n: number };
}, apa: string): Blob {
  const doc = new jsPDF();
  let y = addHeader(doc, data.type === "independent" ? "Independent Samples t-Test" : "Paired Samples t-Test");

  y = addTable(doc, y,
    ["Group", "N", "M", "SD"],
    [
      [data.type === "independent" ? "Group 1" : "Time 1", String(data.group1Stats.n), data.group1Stats.mean.toFixed(2), data.group1Stats.sd.toFixed(2)],
      [data.type === "independent" ? "Group 2" : "Time 2", String(data.group2Stats.n), data.group2Stats.mean.toFixed(2), data.group2Stats.sd.toFixed(2)],
    ]
  );

  y = addTable(doc, y,
    ["Statistic", "Value"],
    [
      ["t", data.t.toFixed(4)],
      ["df", data.type === "independent" ? data.df.toFixed(2) : String(data.df)],
      ["p (two-tailed)", data.pValue < 0.001 ? "< .001" : data.pValue.toFixed(4)],
      ["Cohen's d", data.cohensD.toFixed(4)],
      ["Mean difference", data.meanDiff.toFixed(4)],
      ["95% CI", `[${data.ci95[0].toFixed(4)}, ${data.ci95[1].toFixed(4)}]`],
    ]
  );

  addApa(doc, y, apa);
  addFooter(doc);
  return toBlob(doc);
}

// --- ANOVA PDF ---
export function exportAnovaPdf(data: {
  fStatistic: number; dfBetween: number; dfWithin: number; pValue: number;
  etaSquared: number; ssBetween: number; ssWithin: number; ssTotal: number;
  msBetween: number; msWithin: number;
  groupStats: { name: string; n: number; mean: number; sd: number }[];
}, apa: string): Blob {
  const doc = new jsPDF();
  let y = addHeader(doc, "One-Way ANOVA");

  y = addTable(doc, y,
    ["Source", "SS", "df", "MS", "F", "p"],
    [
      ["Between", data.ssBetween.toFixed(2), String(data.dfBetween), data.msBetween.toFixed(2), data.fStatistic.toFixed(2), data.pValue < .001 ? "< .001" : data.pValue.toFixed(3)],
      ["Within", data.ssWithin.toFixed(2), String(data.dfWithin), data.msWithin.toFixed(2), "", ""],
      ["Total", data.ssTotal.toFixed(2), String(data.dfBetween + data.dfWithin), "", "", ""],
    ]
  );

  y = addSection(doc, y, "Effect Size:", `eta-squared = ${data.etaSquared.toFixed(4)}`);

  y = addTable(doc, y,
    ["Group", "N", "M", "SD"],
    data.groupStats.map(g => [g.name, String(g.n), g.mean.toFixed(2), g.sd.toFixed(2)])
  );

  addApa(doc, y, apa);
  addFooter(doc);
  return toBlob(doc);
}

// --- Chi-Square PDF ---
export function exportChiSquarePdf(data: {
  type: string; chiSquare: number; df: number; pValue: number;
  cramersV?: number; observed: number[][] | number[]; expected: number[][] | number[];
  rowTotals?: number[]; colTotals?: number[]; grandTotal?: number;
  rows?: number; cols?: number; significant?: boolean;
}, apa: string): Blob {
  const doc = new jsPDF();
  let y = addHeader(doc, data.type === "independence" ? "Chi-Square Test of Independence" : "Chi-Square Goodness-of-Fit");

  y = addTable(doc, y,
    ["Statistic", "Value"],
    [
      ["Chi-square", data.chiSquare.toFixed(4)],
      ["df", String(data.df)],
      ["p", data.pValue < 0.001 ? "< .001" : data.pValue.toFixed(4)],
      ...(data.cramersV != null ? [["Cramer's V", data.cramersV.toFixed(4)]] : []),
    ]
  );

  addApa(doc, y, apa);
  addFooter(doc);
  return toBlob(doc);
}

// --- Correlation PDF ---
export function exportCorrelationPdf(data: {
  type: string; r: number; t: number; df: number; pValue: number;
  ci95: [number, number]; n: number; r2: number;
}, apa: string): Blob {
  const doc = new jsPDF();
  let y = addHeader(doc, `${data.type === "pearson" ? "Pearson" : "Spearman"} Correlation`);

  y = addTable(doc, y,
    ["Statistic", "Value"],
    [
      [data.type === "pearson" ? "r" : "rho", data.r.toFixed(4)],
      ["R-squared", data.r2.toFixed(4)],
      ["t", data.t.toFixed(4)],
      ["df", String(data.df)],
      ["p (two-tailed)", data.pValue < 0.001 ? "< .001" : data.pValue.toFixed(4)],
      ["95% CI", `[${data.ci95[0].toFixed(4)}, ${data.ci95[1].toFixed(4)}]`],
      ["N", String(data.n)],
    ]
  );

  addApa(doc, y, apa);
  addFooter(doc);
  return toBlob(doc);
}

// --- Descriptive PDF ---
export function exportDescriptivePdf(data: {
  n: number; mean: number; median: number; sd: number; variance: number;
  se: number; min: number; max: number; range: number;
  q1: number; q3: number; iqr: number;
  skewness: number; kurtosis: number; ci95: [number, number];
}): Blob {
  const doc = new jsPDF();
  const y = addHeader(doc, "Descriptive Statistics");

  addTable(doc, y,
    ["Statistic", "Value"],
    [
      ["N", String(data.n)],
      ["Mean", data.mean.toFixed(4)],
      ["Median", data.median.toFixed(4)],
      ["SD", data.sd.toFixed(4)],
      ["Variance", data.variance.toFixed(4)],
      ["SE", data.se.toFixed(4)],
      ["Min", data.min.toFixed(4)],
      ["Max", data.max.toFixed(4)],
      ["Range", data.range.toFixed(4)],
      ["Q1", data.q1.toFixed(4)],
      ["Q3", data.q3.toFixed(4)],
      ["IQR", data.iqr.toFixed(4)],
      ["Skewness", data.skewness.toFixed(4)],
      ["Kurtosis", data.kurtosis.toFixed(4)],
      ["95% CI", `[${data.ci95[0].toFixed(4)}, ${data.ci95[1].toFixed(4)}]`],
    ]
  );

  addFooter(doc);
  return toBlob(doc);
}

// --- One-Sample T PDF ---
export function exportOneSampleTPdf(data: {
  t: number; df: number; pValue: number; cohensD: number;
  ci95: [number, number]; mean: number; sd: number; n: number; testValue: number;
}, apa: string): Blob {
  const doc = new jsPDF();
  let y = addHeader(doc, "One-Sample t-Test");

  y = addTable(doc, y,
    ["Statistic", "Value"],
    [
      ["Test value", String(data.testValue)],
      ["N", String(data.n)],
      ["Sample mean", data.mean.toFixed(4)],
      ["SD", data.sd.toFixed(4)],
      ["t", data.t.toFixed(4)],
      ["df", String(data.df)],
      ["p (two-tailed)", data.pValue < 0.001 ? "< .001" : data.pValue.toFixed(4)],
      ["Cohen's d", data.cohensD.toFixed(4)],
      ["95% CI", `[${data.ci95[0].toFixed(4)}, ${data.ci95[1].toFixed(4)}]`],
    ]
  );

  addApa(doc, y, apa);
  addFooter(doc);
  return toBlob(doc);
}

// --- Mann-Whitney PDF ---
export function exportMannWhitneyPdf(data: {
  uMin: number; z: number; pValue: number; rankBiserialR: number;
  n1: number; n2: number; median1: number; median2: number;
  u1: number; u2: number; meanRank1: number; meanRank2: number;
  effectSizeLabel: string;
}, apa: string): Blob {
  const doc = new jsPDF();
  let y = addHeader(doc, "Mann-Whitney U Test");

  y = addTable(doc, y,
    ["Statistic", "Value"],
    [
      ["U", data.uMin.toFixed(2)],
      ["z", data.z.toFixed(4)],
      ["p (two-tailed)", data.pValue < 0.001 ? "< .001" : data.pValue.toFixed(4)],
      ["Effect size (r)", data.rankBiserialR.toFixed(4)],
      ["n1", String(data.n1)],
      ["n2", String(data.n2)],
      ["Median (Group 1)", data.median1.toFixed(2)],
      ["Median (Group 2)", data.median2.toFixed(2)],
    ]
  );

  addApa(doc, y, apa);
  addFooter(doc);
  return toBlob(doc);
}

// --- Wilcoxon PDF ---
export function exportWilcoxonPdf(data: {
  wStat: number; z: number; pValue: number; rankBiserialR: number;
  n: number; nEffective: number; effectSizeLabel: string;
}, apa: string): Blob {
  const doc = new jsPDF();
  let y = addHeader(doc, "Wilcoxon Signed-Rank Test");

  y = addTable(doc, y,
    ["Statistic", "Value"],
    [
      ["W", data.wStat.toFixed(2)],
      ["z", data.z.toFixed(4)],
      ["p (two-tailed)", data.pValue < 0.001 ? "< .001" : data.pValue.toFixed(4)],
      ["Effect size (r)", data.rankBiserialR.toFixed(4)],
      ["N", String(data.n)],
      ["N (effective)", String(data.nEffective)],
    ]
  );

  addApa(doc, y, apa);
  addFooter(doc);
  return toBlob(doc);
}

// --- Regression PDF ---
export function exportRegressionPdf(data: {
  slope: number; intercept: number; r: number; rSquared: number;
  fStatistic: number; pValue: number; se: number; n: number;
  adjustedRSquared: number;
}, apa: string): Blob {
  const doc = new jsPDF();
  let y = addHeader(doc, "Simple Linear Regression");

  y = addTable(doc, y,
    ["Statistic", "Value"],
    [
      ["Slope (b)", data.slope.toFixed(4)],
      ["Intercept (a)", data.intercept.toFixed(4)],
      ["r", data.r.toFixed(4)],
      ["R-squared", data.rSquared.toFixed(4)],
      ["F", data.fStatistic.toFixed(4)],
      ["p", data.pValue < 0.001 ? "< .001" : data.pValue.toFixed(4)],
      ["SE of estimate", data.se.toFixed(4)],
      ["N", String(data.n)],
    ]
  );

  y = addSection(doc, y, "Equation:", `Y = ${data.intercept.toFixed(4)} + ${data.slope.toFixed(4)} * X`);

  addApa(doc, y, apa);
  addFooter(doc);
  return toBlob(doc);
}

// --- Cronbach's Alpha PDF ---
export function exportCronbachAlphaPdf(data: {
  alpha: number; interpretation: string; nItems: number; nCases: number;
  scaleMean: number; scaleVariance: number;
  standardizedAlpha: number; splitHalfReliability: number; spearmanBrownReliability: number;
  itemStats: { name: string; mean: number; sd: number; correctedItemTotalR: number; alphaIfDeleted: number }[];
}, apa: string): Blob {
  const doc = new jsPDF();
  let y = addHeader(doc, "Cronbach's Alpha - Reliability Analysis");

  y = addTable(doc, y,
    ["Statistic", "Value"],
    [
      ["Cronbach's Alpha", data.alpha.toFixed(4)],
      ["Interpretation", data.interpretation],
      ["N Items", String(data.nItems)],
      ["N Cases", String(data.nCases)],
      ["Scale Mean", data.scaleMean.toFixed(4)],
      ["Scale Variance", data.scaleVariance.toFixed(4)],
      ["Standardized Alpha", data.standardizedAlpha.toFixed(4)],
      ["Split-Half Reliability", data.splitHalfReliability.toFixed(4)],
      ["Spearman-Brown", data.spearmanBrownReliability.toFixed(4)],
    ]
  );

  y += 4;
  if (y > 200) { doc.addPage(); y = MARGIN; }

  y = addTable(doc, y,
    ["Item", "Mean", "SD", "Item-Total r", "Alpha if Deleted"],
    data.itemStats.map(item => [
      item.name,
      item.mean.toFixed(2),
      item.sd.toFixed(2),
      item.correctedItemTotalR.toFixed(4),
      item.alphaIfDeleted.toFixed(4),
    ])
  );

  addApa(doc, y, apa);
  addFooter(doc);
  return toBlob(doc);
}

// --- Multiple Regression PDF ---
export function exportMultipleRegressionPdf(data: {
  n: number; k: number; rSquared: number; adjustedRSquared: number; r: number;
  fStatistic: number; dfRegression: number; dfResidual: number; pValue: number;
  se: number; durbinWatson: number;
  coefficients: { name: string; b: number; se: number; beta: number; t: number; p: number; ci95: [number, number]; vif: number }[];
  anova: { source: string; ss: number; df: number; ms: number; f: number; p: number }[];
}, apa: string): Blob {
  const doc = new jsPDF();
  let y = addHeader(doc, "Multiple Regression Analysis");

  y = addTable(doc, y,
    ["Statistic", "Value"],
    [
      ["R²", data.rSquared.toFixed(4)],
      ["Adjusted R²", data.adjustedRSquared.toFixed(4)],
      ["Multiple R", data.r.toFixed(4)],
      ["F", `F(${data.dfRegression}, ${data.dfResidual}) = ${data.fStatistic.toFixed(4)}`],
      ["p", data.pValue < 0.001 ? "< .001" : data.pValue.toFixed(4)],
      ["SE of Estimate", data.se.toFixed(4)],
      ["Durbin-Watson", data.durbinWatson.toFixed(4)],
      ["N", String(data.n)],
      ["Predictors", String(data.k)],
    ]
  );

  y = addTable(doc, y,
    ["Predictor", "B", "SE", "Beta", "t", "p", "VIF"],
    data.coefficients.map(c => [
      c.name,
      c.b.toFixed(4),
      c.se.toFixed(4),
      c.name === "(Intercept)" ? "—" : c.beta.toFixed(4),
      c.t.toFixed(4),
      c.p < 0.001 ? "< .001" : c.p.toFixed(3),
      c.name === "(Intercept)" ? "—" : c.vif.toFixed(2),
    ])
  );

  y = addTable(doc, y,
    ["Source", "SS", "df", "MS", "F", "p"],
    data.anova.map(row => [
      row.source,
      row.ss.toFixed(2),
      String(row.df),
      row.source === "Total" ? "" : row.ms.toFixed(2),
      row.source === "Regression" ? row.f.toFixed(2) : "",
      row.source === "Regression" ? (row.p < 0.001 ? "< .001" : row.p.toFixed(3)) : "",
    ])
  );

  addApa(doc, y, apa);
  addFooter(doc);
  return toBlob(doc);
}

// --- Logistic Regression PDF ---
export function exportLogisticRegressionPdf(data: {
  n: number; k: number; converged: boolean; iterations: number;
  neg2LL: number; neg2LLNull: number; omnibusChiSq: number; omnibusDf: number; omnibusP: number;
  coxSnellR2: number; nagelkerkeR2: number;
  coefficients: { name: string; b: number; se: number; wald: number; df: number; p: number; expB: number; expBCI95: [number, number] }[];
  classification: { tn: number; fp: number; fn: number; tp: number; sensitivity: number; specificity: number; accuracy: number };
  hosmerLemeshowChiSq: number; hosmerLemeshowDf: number; hosmerLemeshowP: number;
}, apa: string): Blob {
  const doc = new jsPDF();
  let y = addHeader(doc, "Logistic Regression Analysis");

  y = addTable(doc, y,
    ["Statistic", "Value"],
    [
      ["Omnibus χ²", `χ²(${data.omnibusDf}) = ${data.omnibusChiSq.toFixed(4)}`],
      ["Omnibus p", data.omnibusP < 0.001 ? "< .001" : data.omnibusP.toFixed(4)],
      ["-2 Log Likelihood", data.neg2LL.toFixed(4)],
      ["-2LL (Null)", data.neg2LLNull.toFixed(4)],
      ["Cox & Snell R²", data.coxSnellR2.toFixed(4)],
      ["Nagelkerke R²", data.nagelkerkeR2.toFixed(4)],
      ["N", String(data.n)],
      ["Predictors", String(data.k)],
      ["Converged", data.converged ? "Yes" : "No"],
      ["Iterations", String(data.iterations)],
    ]
  );

  y = addTable(doc, y,
    ["Variable", "B", "S.E.", "Wald", "p", "Exp(B)", "95% CI"],
    data.coefficients.map(c => [
      c.name,
      c.b.toFixed(4),
      c.se.toFixed(4),
      c.wald.toFixed(4),
      c.p < 0.001 ? "< .001" : c.p.toFixed(3),
      c.expB.toFixed(4),
      `[${c.expBCI95[0].toFixed(3)}, ${c.expBCI95[1].toFixed(3)}]`,
    ])
  );

  y = addSection(doc, y, "Classification:",
    `Accuracy: ${(data.classification.accuracy * 100).toFixed(1)}% | ` +
    `Sensitivity: ${(data.classification.sensitivity * 100).toFixed(1)}% | ` +
    `Specificity: ${(data.classification.specificity * 100).toFixed(1)}%`
  );

  y = addSection(doc, y, "Hosmer-Lemeshow:",
    `χ²(${data.hosmerLemeshowDf}) = ${data.hosmerLemeshowChiSq.toFixed(4)}, ` +
    `p = ${data.hosmerLemeshowP < 0.001 ? "< .001" : data.hosmerLemeshowP.toFixed(4)}`
  );

  addApa(doc, y, apa);
  addFooter(doc);
  return toBlob(doc);
}

// --- Factor Analysis PDF ---
export function exportFactorAnalysisPdf(data: {
  nVariables: number; nObservations: number; nFactors: number;
  extractionMethod: string; rotationMethod: string;
  kmo: { overall: number; interpretation: string };
  bartlett: { chiSquare: number; df: number; pValue: number };
  varianceExplainedInitial: { factor: number; eigenvalue: number; percentOfVariance: number; cumulativePercent: number }[];
  rotatedLoadings: number[][];
  communalities: { variable: string; initial: number; extraction: number }[];
  variableNames: string[];
  patternMatrix?: number[][];
  factorCorrelationMatrix?: number[][];
}, apa: string): Blob {
  const doc = new jsPDF();
  let y = addHeader(doc, "Exploratory Factor Analysis");

  y = addTable(doc, y,
    ["Statistic", "Value"],
    [
      ["N (observations)", String(data.nObservations)],
      ["Variables", String(data.nVariables)],
      ["Factors extracted", String(data.nFactors)],
      ["Extraction", data.extractionMethod.toUpperCase()],
      ["Rotation", data.rotationMethod === "none" ? "None" : data.rotationMethod.charAt(0).toUpperCase() + data.rotationMethod.slice(1)],
      ["KMO", `${data.kmo.overall.toFixed(4)} (${data.kmo.interpretation})`],
      ["Bartlett's chi-sq", `${data.bartlett.chiSquare.toFixed(2)} (df=${data.bartlett.df}, p ${data.bartlett.pValue < 0.001 ? "< .001" : "= " + data.bartlett.pValue.toFixed(3)})`],
    ]
  );

  // Variance explained
  y = addTable(doc, y,
    ["Factor", "Eigenvalue", "% Variance", "Cumulative %"],
    data.varianceExplainedInitial.filter(r => r.factor <= data.nFactors).map(r => [
      String(r.factor),
      r.eigenvalue.toFixed(4),
      r.percentOfVariance.toFixed(2) + "%",
      r.cumulativePercent.toFixed(2) + "%",
    ])
  );

  // Factor loadings
  const loadings = data.patternMatrix ?? data.rotatedLoadings;
  const factorHeaders = ["Variable", ...Array.from({ length: data.nFactors }, (_, i) => `Factor ${i + 1}`)];
  y = addTable(doc, y,
    factorHeaders,
    loadings.map((row, i) => [
      data.variableNames[i] ?? `V${i + 1}`,
      ...row.slice(0, data.nFactors).map(v => v.toFixed(3)),
    ])
  );

  // Communalities
  if (y > 220) { doc.addPage(); y = MARGIN; }
  y = addTable(doc, y,
    ["Variable", "Initial", "Extraction"],
    data.communalities.map(c => [c.variable, c.initial.toFixed(4), c.extraction.toFixed(4)])
  );

  // Factor correlations (Promax)
  if (data.factorCorrelationMatrix && data.factorCorrelationMatrix.length > 0) {
    if (y > 240) { doc.addPage(); y = MARGIN; }
    const corrHeaders = ["", ...Array.from({ length: data.nFactors }, (_, i) => `F${i + 1}`)];
    y = addTable(doc, y,
      corrHeaders,
      data.factorCorrelationMatrix.map((row, i) => [
        `Factor ${i + 1}`,
        ...row.map(v => v.toFixed(3)),
      ])
    );
  }

  addApa(doc, y, apa);
  addFooter(doc);
  return toBlob(doc);
}

// --- Sample Size PDF ---
export function exportSampleSizePdf(data: {
  nTotal: number; nPerGroup: number; effectSize: number;
  effectSizeLabel: string; alpha: number; power: number;
  achievedPower: number; testType: string;
}, apa: string): Blob {
  const doc = new jsPDF();
  let y = addHeader(doc, "Sample Size / Power Analysis");

  y = addTable(doc, y,
    ["Parameter", "Value"],
    [
      ["Test type", data.testType],
      ["Required N (total)", String(data.nTotal)],
      ["N per group", String(data.nPerGroup)],
      ["Effect size", data.effectSize.toFixed(2)],
      ["Effect size label", data.effectSizeLabel],
      ["Alpha", data.alpha.toFixed(2)],
      ["Target power", data.power.toFixed(2)],
      ["Achieved power", `${(data.achievedPower * 100).toFixed(1)}%`],
    ]
  );

  addApa(doc, y, apa);
  addFooter(doc);
  return toBlob(doc);
}

// --- Kruskal-Wallis PDF ---
export function exportKruskalWallisPdf(data: {
  hStatistic: number; df: number; pValue: number; etaSquaredH: number;
  epsilonSquared?: number; effectSizeLabel: string;
  groupStats: { name: string; n: number; median: number; meanRank: number }[];
  postHoc: { group1: string; group2: string; z: number; pValue: number; significant: boolean }[];
}, apa: string): Blob {
  const doc = new jsPDF();
  let y = addHeader(doc, "Kruskal-Wallis H Test");

  y = addTable(doc, y,
    ["Statistic", "Value"],
    [
      ["H", data.hStatistic.toFixed(4)],
      ["df", String(data.df)],
      ["p (two-tailed)", data.pValue < 0.001 ? "< .001" : data.pValue.toFixed(4)],
      ["Effect size (\u03B7\u00B2H)", data.etaSquaredH.toFixed(4)],
      ["Effect size (\u03B5\u00B2)", data.epsilonSquared?.toFixed(4) ?? "N/A"],
      ["Effect size label", data.effectSizeLabel],
    ]
  );

  y = addSection(doc, y, "Group Statistics:", "");
  y = addTable(doc, y,
    ["Group", "N", "Median", "Mean Rank"],
    data.groupStats.map(g => [g.name, String(g.n), g.median.toFixed(2), g.meanRank.toFixed(2)])
  );

  if (data.postHoc.length > 0) {
    y = addSection(doc, y, "Dunn's Post-Hoc Comparisons (Bonferroni):", "");
    y = addTable(doc, y,
      ["Comparison", "z", "p", "Sig."],
      data.postHoc.map(ph => [
        `${ph.group1} vs ${ph.group2}`,
        ph.z.toFixed(2),
        ph.pValue < 0.001 ? "< .001" : ph.pValue.toFixed(3),
        ph.significant ? "*" : "ns",
      ])
    );
  }

  addApa(doc, y, apa);
  addFooter(doc);
  return toBlob(doc);
}

// --- Friedman PDF ---
export function exportFriedmanPdf(data: {
  chiSquare: number; df: number; pValue: number; kendallW: number;
  effectSizeLabel: string; n: number; k: number;
  conditionStats: { name: string; n: number; median: number; meanRank: number }[];
  postHoc: { condition1: string; condition2: string; z: number; pValue: number; significant: boolean }[];
}, apa: string): Blob {
  const doc = new jsPDF();
  let y = addHeader(doc, "Friedman Test");

  y = addTable(doc, y,
    ["Statistic", "Value"],
    [
      ["\u03C7\u00B2", data.chiSquare.toFixed(4)],
      ["df", String(data.df)],
      ["p (two-tailed)", data.pValue < 0.001 ? "< .001" : data.pValue.toFixed(4)],
      ["Kendall's W", data.kendallW.toFixed(4)],
      ["Effect size label", data.effectSizeLabel],
      ["N (subjects)", String(data.n)],
      ["k (conditions)", String(data.k)],
    ]
  );

  y = addSection(doc, y, "Condition Statistics:", "");
  y = addTable(doc, y,
    ["Condition", "N", "Median", "Mean Rank"],
    data.conditionStats.map(c => [c.name, String(c.n), c.median.toFixed(2), c.meanRank.toFixed(2)])
  );

  if (data.postHoc.length > 0) {
    y = addSection(doc, y, "Post-Hoc Pairwise Comparisons (Bonferroni):", "");
    y = addTable(doc, y,
      ["Comparison", "z", "p", "Sig."],
      data.postHoc.map(ph => [
        `${ph.condition1} vs ${ph.condition2}`,
        ph.z.toFixed(2),
        ph.pValue < 0.001 ? "< .001" : ph.pValue.toFixed(3),
        ph.significant ? "*" : "ns",
      ])
    );
  }

  addApa(doc, y, apa);
  addFooter(doc);
  return toBlob(doc);
}

// --- Two-Way ANOVA PDF ---
export function exportTwoWayAnovaPdf(data: {
  factorA: { ss: number; df: number; ms: number; f: number; p: number; etaSq: number };
  factorB: { ss: number; df: number; ms: number; f: number; p: number; etaSq: number };
  interaction: { ss: number; df: number; ms: number; f: number; p: number; etaSq: number };
  residual: { ss: number; df: number; ms: number };
  total: { ss: number; df: number };
  cellStats: { factorA: string; factorB: string; n: number; mean: number; sd: number }[];
}, apa: string): Blob {
  const doc = new jsPDF();
  let y = addHeader(doc, "Two-Way (Factorial) ANOVA");
  const fmt = (v: number) => v < 0.001 ? "< .001" : v.toFixed(3);

  y = addTable(doc, y,
    ["Source", "SS", "df", "MS", "F", "p", "\u03B7\u00B2"],
    [
      ["Factor A", data.factorA.ss.toFixed(2), String(data.factorA.df), data.factorA.ms.toFixed(2), data.factorA.f.toFixed(2), fmt(data.factorA.p), data.factorA.etaSq.toFixed(4)],
      ["Factor B", data.factorB.ss.toFixed(2), String(data.factorB.df), data.factorB.ms.toFixed(2), data.factorB.f.toFixed(2), fmt(data.factorB.p), data.factorB.etaSq.toFixed(4)],
      ["A \u00D7 B", data.interaction.ss.toFixed(2), String(data.interaction.df), data.interaction.ms.toFixed(2), data.interaction.f.toFixed(2), fmt(data.interaction.p), data.interaction.etaSq.toFixed(4)],
      ["Residual", data.residual.ss.toFixed(2), String(data.residual.df), data.residual.ms.toFixed(2), "", "", ""],
      ["Total", data.total.ss.toFixed(2), String(data.total.df), "", "", "", ""],
    ]
  );

  y = addTable(doc, y,
    ["A", "B", "N", "M", "SD"],
    data.cellStats.map(c => [c.factorA, c.factorB, String(c.n), c.mean.toFixed(2), c.sd.toFixed(2)])
  );

  addApa(doc, y, apa);
  addFooter(doc);
  return toBlob(doc);
}

// --- Repeated Measures ANOVA PDF ---
export function exportRepeatedMeasuresPdf(data: {
  fStatistic: number; dfConditions: number; dfError: number; pValue: number;
  partialEtaSquared: number; ssConditions: number; ssSubjects: number; ssError: number; ssTotal: number;
  msConditions: number; msError: number;
  sphericity: { mauchlyW: number; chiSquare: number; p: number; ggEpsilon: number; violated: boolean };
  correctedF?: { df1: number; df2: number; p: number };
  conditionStats: { name: string; n: number; mean: number; sd: number }[];
  postHoc: { condition1: string; condition2: string; meanDiff: number; tValue: number; pValue: number; significant: boolean }[];
}, apa: string): Blob {
  const doc = new jsPDF();
  let y = addHeader(doc, "Repeated Measures ANOVA");
  const fmt = (v: number) => v < 0.001 ? "< .001" : v.toFixed(3);

  y = addTable(doc, y,
    ["Source", "SS", "df", "MS", "F", "p"],
    [
      ["Conditions", data.ssConditions.toFixed(2), String(data.dfConditions), data.msConditions.toFixed(2), data.fStatistic.toFixed(2), fmt(data.pValue)],
      ["Subjects", data.ssSubjects.toFixed(2), "", "", "", ""],
      ["Error", data.ssError.toFixed(2), String(data.dfError), data.msError.toFixed(2), "", ""],
      ["Total", data.ssTotal.toFixed(2), "", "", "", ""],
    ]
  );

  y = addSection(doc, y, "Effect Size:", `partial \u03B7\u00B2 = ${data.partialEtaSquared.toFixed(4)}`);

  y = addSection(doc, y, "Sphericity (Mauchly's):",
    `W = ${data.sphericity.mauchlyW.toFixed(4)}, \u03C7\u00B2 = ${data.sphericity.chiSquare.toFixed(2)}, ` +
    `p = ${fmt(data.sphericity.p)}, GG \u03B5 = ${data.sphericity.ggEpsilon.toFixed(4)}` +
    (data.sphericity.violated && data.correctedF ? ` \u2192 Corrected: F(${data.correctedF.df1.toFixed(2)}, ${data.correctedF.df2.toFixed(2)}), p = ${fmt(data.correctedF.p)}` : "")
  );

  y = addTable(doc, y,
    ["Condition", "N", "M", "SD"],
    data.conditionStats.map(c => [c.name, String(c.n), c.mean.toFixed(2), c.sd.toFixed(2)])
  );

  if (data.postHoc.length > 0) {
    y = addSection(doc, y, "Post-Hoc Pairwise Comparisons (Bonferroni):", "");
    y = addTable(doc, y,
      ["Comparison", "Mean Diff", "t", "p", "Sig."],
      data.postHoc.map(ph => [
        `${ph.condition1} vs ${ph.condition2}`,
        ph.meanDiff.toFixed(2),
        ph.tValue.toFixed(2),
        ph.pValue < 0.001 ? "< .001" : ph.pValue.toFixed(3),
        ph.significant ? "*" : "ns",
      ])
    );
  }

  addApa(doc, y, apa);
  addFooter(doc);
  return toBlob(doc);
}

// --- Fisher's Exact Test PDF ---
export function exportFisherExactPdf(data: {
  pValue: number; oddsRatio: number; oddsRatioCI: [number, number];
  phi: number; relativeRisk: number; relativeRiskCI: [number, number];
  observed: number[][]; grandTotal: number;
}, apa: string): Blob {
  const doc = new jsPDF();
  let y = addHeader(doc, "Fisher's Exact Test");

  y = addTable(doc, y,
    ["Statistic", "Value"],
    [
      ["p (exact)", data.pValue < 0.001 ? "< .001" : data.pValue.toFixed(4)],
      ["Odds Ratio", data.oddsRatio === Infinity ? "\u221E" : data.oddsRatio.toFixed(4)],
      ["OR 95% CI", `[${data.oddsRatioCI[0].toFixed(3)}, ${data.oddsRatioCI[1] === Infinity ? "\u221E" : data.oddsRatioCI[1].toFixed(3)}]`],
      ["Relative Risk", data.relativeRisk === Infinity ? "\u221E" : data.relativeRisk.toFixed(4)],
      ["RR 95% CI", `[${data.relativeRiskCI[0].toFixed(3)}, ${data.relativeRiskCI[1] === Infinity ? "\u221E" : data.relativeRiskCI[1].toFixed(3)}]`],
      ["Phi (\u03C6)", data.phi.toFixed(4)],
      ["N", String(data.grandTotal)],
    ]
  );

  y = addTable(doc, y,
    ["", "Col 1", "Col 2"],
    [
      ["Row 1", String(data.observed[0][0]), String(data.observed[0][1])],
      ["Row 2", String(data.observed[1][0]), String(data.observed[1][1])],
    ]
  );

  addApa(doc, y, apa);
  addFooter(doc);
  return toBlob(doc);
}

// --- McNemar Test PDF ---
export function exportMcNemarPdf(data: {
  chiSquare: number; df: number; pValue: number; exactP: number | null;
  oddsRatio: number; oddsRatioCI: [number, number];
  b: number; c: number; discordantTotal: number; proportionChanged: number;
  observed: number[][]; n: number; useExact: boolean;
}, apa: string): Blob {
  const doc = new jsPDF();
  let y = addHeader(doc, "McNemar Test");

  y = addTable(doc, y,
    ["Statistic", "Value"],
    [
      ["\u03C7\u00B2", data.chiSquare.toFixed(4)],
      ["df", String(data.df)],
      ["p (\u03C7\u00B2)", data.pValue < 0.001 ? "< .001" : data.pValue.toFixed(4)],
      ...(data.exactP != null ? [["p (exact)", data.exactP < 0.001 ? "< .001" : data.exactP.toFixed(4)]] : []),
      ["Odds Ratio (b/c)", data.oddsRatio === Infinity ? "\u221E" : data.oddsRatio.toFixed(4)],
      ["OR 95% CI", `[${data.oddsRatioCI[0].toFixed(3)}, ${data.oddsRatioCI[1] === Infinity ? "\u221E" : data.oddsRatioCI[1].toFixed(3)}]`],
      ["Discordant pairs", `b=${data.b}, c=${data.c} (total=${data.discordantTotal})`],
      ["Proportion changed", (data.proportionChanged * 100).toFixed(1) + "%"],
      ["N", String(data.n)],
    ]
  );

  y = addTable(doc, y,
    ["", "Post +", "Post \u2212"],
    [
      ["Pre +", String(data.observed[0][0]), String(data.observed[0][1])],
      ["Pre \u2212", String(data.observed[1][0]), String(data.observed[1][1])],
    ]
  );

  addApa(doc, y, apa);
  addFooter(doc);
  return toBlob(doc);
}
